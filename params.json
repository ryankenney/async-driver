{"name":"Async-driver","tagline":"Treat asynchrouns Java actions as synchronous. Don't just chain actions together, write standard delarative logic without callbacks!","body":"No dependencies. 100% pure Java. Works with GWT. Tastes great. Less filling.\r\n\r\nContents\r\n--------------------\r\n\r\n* [The Problem](#the-problem)\r\n* [jasync-driver Example](#jasync-driver-example)\r\n* [Critical Rules of the Road](#critical-rules-of-the-road)\r\n* [How it Works](#how-it-works)\r\n* [FAQ](#faq)\r\n\r\nThe Problem\r\n--------------------\r\n\r\nImagine that you want to model this logic in a java gui:\r\n\r\n* On User Click\r\n\t* Read User Permissions\r\n\t* If User Has \"edit\" Permissions\r\n\t\t* Prompt User for New Value\r\n\t\t* Store New Value\r\n\t\t* If Store Fails\r\n\t\t\t* Notify User of Failure\r\n\t* If User Does Not Have \"edit\" Permissions\r\n\t\t* Notify User of Permissions Issue\r\n\r\nBecause many of these actions are asynchronous (they require a server or user response before resuming), you can end up with code that looks like this:\r\n\r\n```java\r\n\tpublic void onUserClick() {\r\n\t\treadUserPermissions();\r\n\t}\r\n\r\n\tvoid readUserPermissions() {\r\n\t\twebServer.readUserPermissions(user, new ReturnCallback<Permissions> () {\r\n\t\t\tpublic void handleResult(Permissions permissions) {\r\n\t\t\t\tif (permissions.permissions.contains(\"edit\")) {\r\n\t\t\t\t\tpromptUserForNewValue();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnotifyPermissionsError();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tvoid notifyPermissionsError() {\r\n\t\tuserInterface.showError(\"User does not have edit permission\");\r\n\t}\r\n\r\n\tvoid promptUserForNewValue() {\r\n\t\tuserInterface.promptForNewValue(new ReturnCallback<String> () {\r\n\t\t\t@Override\r\n\t\t\tpublic void handleResult(String result) {\r\n\t\t\t\tupdateStoredValue(result);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tvoid updateStoredValue(String value) {\r\n\t\twebServer.storeValue(value, new ReturnCallback<Status> () {\r\n\t\t\t@Override\r\n\t\t\tpublic void handleResult(Status result) {\r\n\t\t\t\tif (result != Status.OK) {\r\n\t\t\t\t\tnotifyStoreError();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tvoid notifyStoreError() {\r\n\t\tuserInterface.showError(\"Store action failed\");\r\n\t}\r\n```\r\n\r\nWhere did that nice little block of conditional logic go? It got smeared across all of the callback methods necesssary to string the asynchronous actions together.\r\n\r\njasync-driver Example\r\n--------------------\r\n\r\nWith jasync-driver, we can define the logic block as if everything is synchronous.\r\nFor example, this models the logic above:\r\n\r\n```java\r\n\tfinal JasyncDriver driver = new JasyncDriver();\r\n\tdriver.execute(new DriverBody() {\r\n\t\tpublic void run() {\r\n\t\t\tPermissions permissions = driver.execute(readUserPermissions, user);\r\n\t\t\tif (!driver.execute(hasEditPermission, permissions)) {\r\n\t\t\t\tdriver.execute(notifyPermissionsError);\r\n\t\t\t} else {\r\n\t\t\t\tString userInput = driver.execute(promptUserForNewValue);\r\n\t\t\t\tStatus storeStatus = driver.execute(updateStoredValue, userInput);\r\n\t\t\t\tif (storeStatus != Status.OK) {\r\n\t\t\t\t\tdriver.execute(notifyStoreError);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n```\r\n\r\nFrom here, you have to wrap each of the asynchronous actions in a Task object,\r\nbut the resulting code is arguably much more legible. Here is a more complete example:\r\n\r\n```java\r\nWebServer webServer;\r\nUserInterface userInterface;\r\nUser user;\r\n\r\npublic void onUserClick() {\r\n\t\r\n\tfinal AsyncTask<User,Permissions> readUserPermissions = new AsyncTask<User,Permissions>() {\r\n\t\tpublic void run(final User user, final ResultHandler<Permissions> resultHandler) {\r\n\t\t\twebServer.readUserPermissions(user, new ReturnCallback<Permissions> () {\r\n\t\t\t\tpublic void handleResult(Permissions result) {\r\n\t\t\t\t\tresultHandler.reportComplete(result);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n\r\n\tfinal SyncTask<Permissions,Boolean> hasEditPermission = new SyncTask<Permissions,Boolean>() {\r\n\t\tpublic Boolean run(Permissions permissions) {\r\n\t\t\treturn permissions.permissions.contains(\"edit\");\r\n\t\t}\r\n\t};\r\n\r\n\tfinal SyncTask<Void,Void> notifyPermissionsError = new SyncTask<Void,Void>() {\r\n\t\tpublic Void run(Void arg) {\r\n\t\t\tuserInterface.showError(\"User does not have edit permission\");\r\n\t\t\treturn null;\r\n\t\t}\r\n\t};\r\n\r\n\tfinal AsyncTask<Void,String> promptUserForNewValue = new AsyncTask<Void,String>() {\r\n\t\tpublic void run(final Void  arg, final ResultHandler<String> resultHandler) {\r\n\t\t\tuserInterface.promptForNewValue(new ReturnCallback<String> () {\r\n\t\t\t\tpublic void handleResult(String result) {\r\n\t\t\t\t\tresultHandler.reportComplete(result);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n\r\n\tfinal AsyncTask<String,Status> updateStoredValue = new AsyncTask<String,Status>() {\r\n\t\tpublic void run(final String value, final ResultHandler<Status> resultHandler) {\r\n\t\t\twebServer.storeValue(value, new ReturnCallback<Status> () {\r\n\t\t\t\tpublic void handleResult(Status result) {\r\n\t\t\t\t\tresultHandler.reportComplete(result);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n\r\n\tfinal SyncTask<Void,Void> notifyStoreError = new SyncTask<Void,Void>() {\r\n\t\tpublic Void run(Void arg) {\r\n\t\t\tuserInterface.showError(\"Store action failed\");\r\n\t\t\treturn null;\r\n\t\t}\r\n\t};\r\n\r\n\tfinal JasyncDriver driver = new JasyncDriver();\r\n\tdriver.execute(new DriverBody() {\r\n\t\tpublic void run() {\r\n\t\t\t\r\n\t\t\tPermissions permissions = driver.execute(readUserPermissions, user);\r\n\t\t\tif (!driver.execute(hasEditPermission, permissions)) {\r\n\t\t\t\tdriver.execute(notifyPermissionsError);\r\n\t\t\t} else {\r\n\t\t\t\tString userInput = driver.execute(promptUserForNewValue);\r\n\t\t\t\tStatus storeStatus = driver.execute(updateStoredValue, userInput);\r\n\t\t\t\tif (storeStatus != Status.OK) {\r\n\t\t\t\t\tdriver.execute(notifyStoreError);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n}\r\n```\r\n\r\nCritical Rules of the Road\r\n--------------------\r\n\r\n* **Wrap all reads/writes of non-local data in AsyncTasks/SyncTasks**\r\n\t* ...\r\n* **Don't use try/catch in the AsyncDriver body**\r\n\t* ...\r\n\r\n### Wrap all reads/writes of non-local data in AsyncTasks/SyncTasks\r\n\r\nHere is an example of what not to do (see comments):\r\n\r\n```java\r\n\t\tfinal JasyncDriver driver = new JasyncDriver();\r\n\t\tdriver.execute(new DriverBody() {\r\n\t\t\tpublic void run() {\r\n\t\t\t\tPermissions permissions = driver.execute(readUserPermissions, user);\r\n\t\t\t\t// ERROR: Accessing a class variable! (defined outside of the DriverBody method)\r\n\t\t\t\t// This needs to be wrapped in a SyncTask\r\n\t\t\t\tif (updateServerValueCheckbox.isSet()) {\r\n\t\t\t\t\t// WARNING: This method may or may access external variables\r\n\t\t\t\t\t// within. We can't tell from here, so it's safest to wrap\r\n\t\t\t\t\t// it in a SyncTask to ensure that edits to the method body do\r\n\t\t\t\t\t// not break the DriverBody.\r\n\t\t\t\t\tif (!hasEditPermission(permissions)) {\r\n\t\t\t\t\t\tdriver.execute(notifyPermissionsError);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tString userInput = driver.execute(promptUserForNewValue);\r\n\t\t\t\t\t\tStatus storeStatus = driver.execute(updateStoredValue, userInput);\r\n\t\t\t\t\t\tif (storeStatus != Status.OK) {\r\n\t\t\t\t\t\t\tdriver.execute(notifyStoreError);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n```\r\n\r\njasync-driver can only function properly if all access to variables outside of the **method scope** is wrapped by\r\nAsyncTask/SyncTask and executed by driver.execute(Task).\r\n\r\n\r\n### Don't use try/catch in the JasyncDriver body\r\n\r\nNever use try/catch blocks to cature exceptions escaping from AsyncTask/SyncTask. jasync-driver uses exceptions (Error)\r\nto interrupt execution when waiting for a response from an asynchronus action, so they need to be able to leak\r\nout of the DriverBody.\r\n\r\nHere is an example of what not to do:\r\n\r\n```java\r\n\t\tfinal JasyncDriver driver = new JasyncDriver();\r\n\t\tdriver.execute(new DriverBody() {\r\n\t\t\tpublic void run() {\r\n\t\t\t\t// ERROR: Do not use try/catch blocks within the DriveBody.\r\n\t\t\t\t// Instead, incorporate try/catch logic into the body of one or\r\n\t\t\t\t// more AsyncTask/SyncTax.\r\n\t\t\t\ttry {\r\n\t\t\t\t\tdriver.execute(readUserPermissions, user);\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\tdriver.execute(notifyUserOfReadError);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n```\r\n\r\nHere's a fixed version of that code:\r\n\r\n```java\r\n\t\tfinal JasyncDriver driver = new JasyncDriver();\r\n\t\tdriver.execute(new DriverBody() {\r\n\t\t\tpublic void run() {\r\n\t\t\t\t// NOTE: Now now exception handling here,\r\n\t\t\t\t// but instead it is inside of readUserPermissions\r\n\t\t\t\tdriver.execute(readUserPermissions, user);\r\n\t\t\t\tif (driver.execute(getLastRequestFailed)) {\r\n\t\t\t\t\tdriver.execute(notifyUserOfReadError);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n```\r\n\r\nAnd here's a more complete version of the fix, which shows the exception handling inside of the AsyncTask\r\n(see comments):\r\n\r\n```java\r\n\tWebServer webServer;\r\n\tUserInterface userInterface;\r\n\tUser user;\r\n\t\r\n\tpublic void onUserClick() {\r\n\r\n\t\tfinal AtomicBoolean lastRequestFailed = new AtomicBoolean(false);\r\n\t\t\r\n\t\tfinal AsyncTask<User,Permissions> readUserPermissions = new AsyncTask<User,Permissions>() {\r\n\t\t\tpublic void run(final User user, final ResultHandler<Permissions> resultHandler) {\r\n\t\t\t\twebServer.readUserPermissions(user, new ReturnCallback<Permissions> () {\r\n\t\t\t\t\tpublic void handleResult(Permissions result) {\r\n\t\t\t\t\t\t// Exception handling has been moved inside of this AsyncTask\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tresultHandler.reportComplete(result);\r\n\t\t\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\t\t\t// The exceptional result is stored in an external variable.\r\n\t\t\t\t\t\t\t// That is fine because we're using AsyncTask/SyntTasks\r\n\t\t\t\t\t\t\t// to access the variable.\r\n\t\t\t\t\t\t\tlastRequestFailed.set(true);\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfinal SyncTask<Void,Void> notifyUserOfReadError = new SyncTask<Void,Void>() {\r\n\t\t\tpublic Void run(Void arg) {\r\n\t\t\t\tuserInterface.showError(\"Failed to read from server\");\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\tfinal SyncTask<Void,Boolean> getLastRequestFailed = new SyncTask<Void,Boolean>() {\r\n\t\t\tpublic Boolean run(Void arg) {\r\n\t\t\t\treturn lastRequestFailed.get();\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\tfinal JasyncDriver driver = new JasyncDriver();\r\n\t\tdriver.execute(new DriverBody() {\r\n\t\t\tpublic void run() {\r\n\t\t\t\t// NOTE: Now now exception handling here,\r\n\t\t\t\t// but instead it is inside of readUserPermissions\r\n\t\t\t\tdriver.execute(readUserPermissions, user);\r\n\t\t\t\tif (driver.execute(getLastRequestFailed)) {\r\n\t\t\t\t\tdriver.execute(notifyUserOfReadError);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n```\r\n\r\nHow it Works\r\n--------------------\r\n\r\nHere is the the basic internal execution of jasync-executor:\r\n\r\n* JasyncDriver launches the DriverBody method\r\n* When the DriverBody hits an AsyncTask:\r\n\t* JasyncDriver launches the asynchronous action with a callback to wake up JasyncDriver on return\r\n\t* JasyncDriver throws an Exception (Error) to quickly terminate the DriverBody\r\n* Eventually the asynchronous action's callback wakes up JasyncDriver\r\n* JasyncDriver caches any value returned by the asynchronous action\r\n* JasyncDriver launches the DriverBody method\r\n* When the DriverBody hits the same AsyncTask, it simply uses the cached return value instead of executing it again\r\n* (the same process is repeated for each AsyncTask until the DriverBody exists cleanly)\r\n\r\nThe net effect is that thet DriverBody is potentially run many, many times,\r\nbut the AsyncTasks/SyncTasks are each run only once (or run as many times as they appear in the DriverBody--they can be reused).\r\n\r\nHere is a modified code example that includes logging to demonstration order of execution:\r\n\r\n> Note that this is also prime example of why you cannot access external variables within a DriverBody without an AsyncTask/SyncTask wrapper.\r\n> System.out.printf() is being called many more times than a developer would first expect.\r\n> \r\n> However, in this particular case we're using these log messages to demonstrate the actual exeuction order of things.\r\n\r\n```java\r\npublic void onUserClick() {\r\n\t\r\n\tfinal AsyncTask<User,Permissions> readUserPermissions = new AsyncTask<User,Permissions>() {\r\n\t\tpublic void run(final User user, final ResultHandler<Permissions> resultHandler) {\r\n\t\t\twebServer.readUserPermissions(user, new ReturnCallback<Permissions> () {\r\n\t\t\t\tpublic void handleResult(Permissions result) {\r\n\t\t\t\t\tSystem.out.println(\"== Executing [readUserPermissions] ==\");\r\n\t\t\t\t\tresultHandler.reportComplete(result);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n\r\n\tfinal SyncTask<Permissions,Boolean> hasEditPermission = new SyncTask<Permissions,Boolean>() {\r\n\t\tpublic Boolean run(Permissions permissions) {\r\n\t\t\tSystem.out.println(\"== Executing [hasEditPermission] ==\");\r\n\t\t\treturn permissions.toString().contains(\"edit\");\r\n\t\t}\r\n\t};\r\n\r\n\tfinal SyncTask<Void,Void> notifyPermissionsError = new SyncTask<Void,Void>() {\r\n\t\tpublic Void run(Void arg) {\r\n\t\t\tSystem.out.println(\"== Executing [notifyPermissionsError] ==\");\r\n\t\t\tuserInterface.showError(\"User does not have edit permission\");\r\n\t\t\treturn null;\r\n\t\t}\r\n\t};\r\n\r\n\tfinal AsyncTask<Void,String> promptUserForNewValue = new AsyncTask<Void,String>() {\r\n\t\tpublic void run(final Void  arg, final ResultHandler<String> resultHandler) {\r\n\t\t\tuserInterface.promptForNewValue(new ReturnCallback<String> () {\r\n\t\t\t\tpublic void handleResult(String result) {\r\n\t\t\t\t\tSystem.out.println(\"== Executing [promptUserForNewValue] ==\");\r\n\t\t\t\t\tresultHandler.reportComplete(result);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n\r\n\tfinal AsyncTask<String,Status> updateStoredValue = new AsyncTask<String,Status>() {\r\n\t\tpublic void run(final String value, final ResultHandler<Status> resultHandler) {\r\n\t\t\twebServer.storeValue(value, new ReturnCallback<Status> () {\r\n\t\t\t\tpublic void handleResult(Status result) {\r\n\t\t\t\t\tSystem.out.println(\"== Executing [updateStoredValue] ==\");\r\n\t\t\t\t\tresultHandler.reportComplete(result);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n\r\n\tfinal SyncTask<Void,Void> notifyStoreError = new SyncTask<Void,Void>() {\r\n\t\tpublic Void run(Void arg) {\r\n\t\t\tSystem.out.println(\"== Executing [notifyStoreError]  ==\");\r\n\t\t\tuserInterface.showError(\"Store action failed!\");\r\n\t\t\treturn null;\r\n\t\t}\r\n\t};\r\n\r\n\tfinal JasyncDriver driver = new JasyncDriver();\r\n\tdriver.execute(new DriverBody() {\r\n\t\tpublic void run() {\r\n\t\t\tSystem.out.printf(\"Launching DriverBody%n\");\r\n\t\t\tPermissions permissions = driver.execute(readUserPermissions, user);\r\n\t\t\tSystem.out.printf(\"Value of permissions: %s%n\", permissions);\r\n\t\t\tBoolean hasPermission = driver.execute(hasEditPermission, permissions);\r\n\t\t\tSystem.out.printf(\"Value of hasPermission: %s%n\", hasPermission);\r\n\t\t\tif (!hasPermission) {\r\n\t\t\t\tdriver.execute(notifyPermissionsError);\r\n\t\t\t} else {\r\n\t\t\t\tString userInput = driver.execute(promptUserForNewValue);\r\n\t\t\t\tSystem.out.printf(\"Value of userInput: %s%n\", userInput);\r\n\t\t\t\tStatus storeStatus = driver.execute(updateStoredValue, userInput);\r\n\t\t\t\tSystem.out.printf(\"Value of storeStatus: %s%n\", storeStatus);\r\n\t\t\t\tif (storeStatus != Status.OK) {\r\n\t\t\t\t\tdriver.execute(notifyStoreError);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n}\r\n```\r\n\r\nAnd here's the resulting output of the sample code:\r\n\r\n```\r\nLaunching DriverBody\r\n== Executing [readUserPermissions] ==\r\nLaunching DriverBody\r\nValue of permissions: view,edit\r\n== Executing [hasEditPermission] ==\r\nValue of hasPermission: true\r\n== Executing [promptUserForNewValue] ==\r\nLaunching DriverBody\r\nValue of permissions: view,edit\r\nValue of hasPermission: true\r\nValue of userInput: foobar\r\n== Executing [updateStoredValue] ==\r\nLaunching DriverBody\r\nValue of permissions: view,edit\r\nValue of hasPermission: true\r\nValue of userInput: foobar\r\nValue of storeStatus: FAILURE\r\n== Executing [notifyStoreError]  ==\r\n```\r\n\r\nFAQ\r\n--------------------\r\n\r\n### Can you reuse the same AsynTask/SyncTask multiple times within the same DriverBody?\r\n\r\nYes! jasync-driver caches the result of each Task by execution location,\r\nso it is safe to use the same Task multiple times in the same DriverBody definition.\r\n\r\n### Can you reuse a DriverBody instance?\r\n\r\nYes. The DriverBody retains no state of it's own.\r\n\r\n### Can you reuse a JasyncDriver instance?\r\n\r\nYes. The JasyncDriver resets internal state when the DriverBody terminates cleanly.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}